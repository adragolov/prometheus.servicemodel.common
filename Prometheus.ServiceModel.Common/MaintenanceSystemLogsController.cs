using Microsoft.AspNetCore.Mvc;
using Prometheus.Core.Extensions;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Text;
using Microsoft.AspNetCore.Authorization;

namespace Prometheus.ServiceModel.Common
{
    /// <summary>
    ///     Maintenance controller with endpoints for accessing system logs generated by the service host.
    ///     Requires priviledges for with claims specific for a Maintenance Team.
    /// </summary>
    [Authorize(AuthenticationSchemes = "Bearer", Policy = "RequireMaintenanceTeam")]
    public class MaintenanceSystemLogsController : Controller
    {
        /// <summary>
        ///     Default filter options.
        /// </summary>
        static class Defaults
        {
            /// <summary>
            ///     Logs older by this date will not be retrieved.
            /// </summary>
            public const int MaxDaysFilter = 14;
            /// <summary>
            ///     Stores the default relative path for the log files directory.
            /// </summary>
            public const string LogsDirectoryPath = "logs";
        }
        
        /// <summary>
        ///     Retrieves the names of all file entries registered in the system log of the microservice.
        ///     The entries will be sorted by the last modification timestamp of the log file.
        /// </summary>
        /// <param name="since">
        ///     Filter for log files that are created since the specified date.
        ///     When not provided explicitly, a default filter for two weeks ago is used.
        /// </param>
        /// <response code="200">Returned for authorized requests.</response>
        /// <response code="401">Returned for requests that are not authenticated.</response>
        /// <response code="403">Returned for requests that are not authorized.</response>
        [HttpGet, Route("sys/logs/{since?}")]
        [ProducesResponseType(typeof(IEnumerable<string>), 200)]
        [ProducesResponseType(401)]
        [ProducesResponseType(403)]
        [ProducesResponseType(500)]
        public IActionResult ListLogFiles(DateTime? since)
        {
            try
            {
                since = since ?? DateTime.UtcNow.StartOfTheDay().AddDays(Defaults.MaxDaysFilter * -1);

                var logsRoot = $"{Directory.GetCurrentDirectory()}/{Defaults.LogsDirectoryPath}";

                var directoryInfo = new DirectoryInfo(logsRoot);

                var logFiles = directoryInfo.GetFiles()
                    .Where(fi => fi.CreationTimeUtc > since)
                    .OrderByDescending(fi => fi.LastWriteTimeUtc)
                    .Select(fi => new Model.DTOLogFile
                    {
                        Name = fi.Name,
                        LastUpdateUtc = fi.LastWriteTimeUtc
                    })
                    .ToArray();

                return Ok(logFiles);
            }
            catch (Exception e)
            {
                return this.FatalServerError(e);
            }
        }

        /// <summary>
        ///     Retrieves the contents of a system log from the SMEA domain.
        /// </summary>
        /// <param name="filename">
        ///     The name of the log file. Required.
        /// </param>
        /// <response code="200">Returned for authorized requests.</response>
        /// <response code="401">Returned for requests that are not authenticated.</response>
        /// <response code="403">Returned for requests that are not authorized.</response>
        /// <response code="404">Returned for authorizaed requests that specify an invalid / non-existent filename.</response>
        [HttpGet, Route("sys/log/{filename}")]
        [Produces("text/plain")]
        public async Task<IActionResult> GetLogFileContentsAsync(string filename)
        {
            try
            {
                var filePath = $"{Directory.GetCurrentDirectory()}/{Defaults.LogsDirectoryPath}/{filename}";

                if (!System.IO.File.Exists(filePath))
                {
                    return NotFound();
                }

                using (var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var sr = new StreamReader(fs, Encoding.Default))
                {
                    var fileText = await sr.ReadToEndAsync();

                    return Ok(fileText);
                }
            }
            catch (Exception e)
            {
                return this.FatalServerError(e);
            }
        }
    }
}